# https://stackoverflow.com/questions/61351844/difference-between-multiprocessing-asyncio-threading-and-concurrency-futures-i

import os
import re
import ffmpeg
import shutil


class VideoProcessor:
    def __init__(self, source, target_dir=None, max_size_MB=25):
        self.source = source
        self.target_dir = target_dir or os.path.join(source, "_processed")
        self.max_size_MB = max_size_MB

        self.resolution_options = [
            (1280, 720),   # 720p
            (1024, 576),   # Intermediate tier
            (960, 540)     # Lowest acceptable resolution
        ]

        os.makedirs(self.target_dir, exist_ok=True)

    ### File Wrangling

    # File Name Sanitization
    def _sanitize_filename(self, filename):
        # check if filename is as expected to be generated by Nvidia
        expected_format_match = re.search(r"(Valorant\s*\d{4}\.\d{2}\.\d{2})", filename)
        if expected_format_match:
            name_match = re.search(r"DVR_([\w-]+)", filename)
            clean_name = name_match.group(1).replace("-", " ").replace("_", " ").strip()

            date_match = re.search(r"(\d{4}\.\d{2}\.\d{2})", filename)
            date = date_match.group(1) if date_match else ""

            print(f"\nNEW FILE NAME: {clean_name} {date}")

            return f"{clean_name} {date}"

    # FFmpeg Video Processing
    def _get_video_metadata(self, input_path):
        probe_result = ffmpeg.probe(input_path)

        video_info = None
        for s in probe_result["streams"]:
            if s["codec_type"] == "video":
                video_info = s

        if video_info is None:
            raise ValueError(f"No video stream found in {input_path}")

        width = video_info["width"]
        height = video_info["height"]
        file_size_MB = os.path.getsize(input_path) / (1024 * 1024)  # MB
        bitrate_bps = video_info["bit_rate"]

        return {
            "width": width,
            "height": height,
            "aspect_ratio": width / height,
            "file_size_MB": file_size_MB,
            "bitrate_bps": bitrate_bps,
        }

    def _resize_video(self, input_path, output_path, target_width, target_height):
        try:
            (
                ffmpeg.input(input_path)
                .filter("scale", target_width, target_height)
                .output(
                    output_path,
                    vcodec="libx265",
                    preset="medium",
                    format="mp4",
                )
                .overwrite_output()
                .run(capture_stdout=True, capture_stderr=True)
            )
            return output_path
        except ffmpeg.Error as e:
            print(f"Resize error: {e.stderr.decode()}")
            return None

    ### Optimal Bitrate Calculation Algorithm
    def _calculate_optimal_bitrate(self, input_path):
        metadata = self._get_video_metadata(input_path)
        original_size = metadata["file_size_MB"]

        if original_size <= self.max_size_MB:
            return None  # Compression not needed

        # Superbly Complex bitrate calculations
        # TODO: Factor in resolution into algorithm
        max_size_bits = self.max_size_MB * 8 * 1024 * 1024  # FFmpeg calculates in bits
        duration = float(ffmpeg.probe(input_path)["format"]["duration"])
        target_bitrate = max_size_bits // duration

        print(f"Video_duration: {duration}\n")
        print(f"max_size_kb: {max_size_bits}\n")
        print(f"Target Bitrate: {target_bitrate}\n")
        print(f"CURRENT Bitrate: {metadata["bitrate_bps"]}\n")

        # Min 2000 kbps
        optimal_bitrate = max(target_bitrate, 2000000)
        print(f"OPTIMAL Bitrate: {optimal_bitrate}\n")
        return optimal_bitrate

    def process_video(self):
        """Main file processing method"""
        for root, dirs, files in os.walk(self.source):
            for file in files:
                if file.lower().endswith(".mp4"):
                    file_input_path = os.path.join(root, file)

                    # New filename and output path
                    new_filename = self._sanitize_filename(file)
                    output_path = os.path.join(self.target_dir, new_filename, ".mp4")

                    # If file size less than target, copy to dir, and continue to next iteration
                    # No modifications needed
                    metadata = self._get_video_metadata(file_input_path)
                    if metadata["file_size_MB"] < self.max_size_MB:
                        shutil.copy2(file_input_path, output_path)
                        continue

                    # Resize, compress
                    bitrate = self._calculate_optimal_bitrate(file_input_path)

                    try:
                        (
                            ffmpeg.input(file_input_path)
                            .output(
                                output_path,
                                vcodec="libx265",
                                video_bitrate=bitrate,
                                preset="medium",
                                format="mp4",
                            )
                            .overwrite_output()
                            .run(capture_stdout=True, capture_stderr=True)
                        )
                    except ffmpeg.Error as e:
                        print(f"Compression error: {e.stderr.decode()}")


def main():
    VideoProcessor(r"D:\D_Videos\Captures\NVIDIA\Valorant\2024.10.20").process_video()


if __name__ == "__main__":
    main()
